# JAvascriptにおける非同期処理

## javascriptはシングルスレッド

- 普通に書くと、同時に1つのことしかできない(同期処理)
- 非同期に処理されるAPIを利用することで非同期処理を実現(ex. `setTimeout`, `fs.readFile`)
- callbackを受け取るものや、Promiseを返すものなど色々ある


## なぜ、シングルスレッドなのに、非同期apiを呼ぶだけで非同期処理ができるのか？？

- イベントループを使ってる
- 通常、呼ばれた関数は、コールスタックという処理を実行する場所に積まれて、実行される(キューのイメージ → 後入、先出)
- 非同期の処理はコールスタックから、別のjavascriptの実行環境にオフロードされて実行される(nodeだとC++のAPI,webだとwebAPI)
- 処理が完了すると、メッセージキューにコールバックがキューとして追加されていく
- コールスタックが空になると、イベントループが動き、メッセージキューの中にあるキュー(非同期処理の結果)をコールスタックに1つずつ持ってくる
:::note info
point】イベントループが動けるようにしていないと、非同期処理の結果がいつまで経っても渡ってこない(処理自体は完了してるのに来ない) => mainスレッドでは重たい処理はしないようにする(重たい処理は非同期へ)
:::


## Promise

- Promiseオブジェクトは、非同期処理を呼び出して、いつか結果を返すと約束するもの
- 結果は、成功 or 失敗 で返る
- Promiseのthenメソッドを使って、非同期処理が完了し、成功が帰ってきた時の処理をコールバック関数で登録できる
  - 失敗時は、catchメソッドで登録
- Promiseを使うことで、コールバック関数による非同期処理のネストが解消できる(コールバック地獄からの脱出)
- 標準ライブラリや、サードパーティのライブラリがPromiseを返すAPIを提供してる
  - Promiseが使われてないものでもPromiseでラップして渡せば、できないこともない


## Promiseの順番

1. (メインスレッド)これやって
2. (非同期API)すぐPromiseを返す(裏で処理を開始)
3. (メインスレッド)非同期処理が終わった後の処理を処理(コールバック)を登録
4. (非同期API)終わったら、処理を返す
5. (メインスレッド)返ってきた成功or失敗で登録した処理を実行


## async/await

- async/awaitを利用することで、Promiseチェーンよりすっきり書ける
- ただし、Promiseの上で成り立ってるので、Promiseの理解は必須
- async
  - 関数を非同期にするキーワード
  - 返り値が暗黙的にPromiseになる
- await
  - async関数内でしか使えない
  - Promiseオブジェクトの前につける
- 非同期通信だが、コード上では同期的に上から実行できるのが強み
